//! Node.js
// Node.js - легке та ефективне середовище виконання JavaScript. Дозволяє писати високопродуктивні серверні застосунки та інструменти. Node.js побудована на JavaScript-рушію V8 і написана на C++.

// Спочатку Node.js створювалася як серверне оточення для застосунків, але розробники почали використовувати її для створення інструментів, які допомагають автоматизувати виконання локальних завдань. В результаті нова екосистема інструментів, яка виникла навколо Node.js, призвела до трансформації процесу фронтенд-розробки.

// Встановлення

// Щоб встановити останню стабільну версію, перейдіть на офіційну сторінку, завантажте LTS-інсталятор і дотримуйтесь вказівок. Існують інсталятори для всіх популярних операційних систем - Windows, MacOS і Linux.

//! ЦІКАВО
// Користувачам Windows необхідно вибрати чекбокси для встановлення всіх додаткових інструментів, крім Chocolatey. Це встановить Python і різноманітні допоміжні утиліти і компілятори.

// Після встановлення в терміналі буде доступна команда node. Щоб переконатися, що встановлення пройшло успішно, перевірте версію, запустивши в консолі команду node з прапорцем version.

// node --version

//! JavaScript поза браузером

// Node.js дозволяє виконувати JavaScript-код поза браузером. Відкрийте будь-який термінал і виконайте команду node, запуститься REPL (read-eval-print loop) - інтерактивне середовище виконання JS-коду. Виведемо щось в консоль.

//! ЦІКАВО
// Для того, щоб вийти з REPL, натисніть комбінацію Ctrl + C на Windows і Control + C на MacOS.

// Тепер створимо папку node-tut, а в ній - файл index.js з кодом, який ми писали в REPL. Для запуску потрібно відкрити термінал і перейти в папку node-tut, в якій лежить index.js.

// index.js
const message = 'NodeJS in amazing!';
console.log(message);

// Тепер в консолі запускаємо файл за допомогою команди node index.js і отримуємо такий самий результат - виведення рядка безпосередньо в терміналі.

// В цьому і полягає суть Node.js - можливість виконувати JavaScript поза браузером. Таким чином можна писати цілі застосунки, наприклад, бекенд або утиліти, що не залежать від браузера.

//! Пакетний менеджер npm

// Щоб використовувати все різноманіття інструментів (або пакетів) Node.js, нам необхідна можливість встановлювати і керувати ними. Для цього створений NPM (node package manager) - пакетний менеджер Node.js. Він встановлює потрібні пакети і забезпечує зручний інтерфейс для роботи з ними.

// NPM складається з трьох основних компонентів:

// Сайт npmjs.com - використовується для пошуку та ознайомлення з документацією пакетів.

// Інтерфейс командного рядка (CLI) - запускається з терміналу і надає набір команд для роботи з реєстром і пакетами. Дозволяє створювати скрипти для запуску в терміналі.

// Реєстр пакетів (registry) - велика загальнодоступна база даних інструментів розробки (пакетів).

// Пакет (package) - невелика JavaScript бібліотека, що вирішує специфічне завдання. Пакети пишуть самі розробники і діляться зі спільнотою. Такий підхід спрощує життя, тому що не потрібно винаходити колесо, всі колеса вже давно лежать на полицях реєстру і готові до використання.

//! ЦІКАВО
// Пакети абстрагують реалізацію функціоналу, надаючи розробнику зручний інтерфейс. Це робить код чистішим, читабельнішим і дозволяє простіше його підтримувати.

//! Команди NPM

// Відразу перелічимо основні команди і будемо послідовно використовувати і розглядати в деталях.

// npm init - ініціалізує npm в проекті і створює файл package.json
// npm install - встановлює всі залежності, перелічені в package.json
// npm list --depth=0 - виведе в терміналі список локально встановлених пакетів з номерами їх версій, без залежностей
// npm install [package-name] - встановить пакет локально у папку node_modules
// npm uninstall [package-name] - видалить пакет, встановлений локально і оновить package.json
// npm start і npm test - запустить скрипт start або test, розташований в package.json
// npm run [custom-script] - запустить кастомний скрипт, розташований в package.json
// npm outdated - використовується для пошуку оновлень, виявить сумісні версії програмно і виведе список доступних оновлень
// npm update - оновить всі пакети до максимально дозволеної версії

// https://docs.npmjs.com/

//! Ініціалізація проекту

// Кожен проект починається зі створення файлу package.json - він відстежує залежності, містить службову інформацію, дозволяє писати npm-скрипти і слугує інструкцією під час створення нового проекту на основі вже готових налаштувань. Файл package.json можна створити npm-командою init, що ініціалізує проект в цій папці.

// npm init

// Вам буде запропоновано ввести назву проекту, версію, опис тощо. Можна просто натискати Enter доти, доки не буде створений package.json і розміщений в папці проекту. Щоб не натискати Enter, пропускаючи порожні поля, використовується команда init з прапорцем --yes. Прапорець - додаткове налаштування для команди.

// npm init --yes

//! ЦІКАВО
// У кожного прапорця є псевдонім - його скорочений запис. Псевдонім прапорця --yes - -y, тому команди npm init --yes і npm init -y роблять одне і те ж.

// Буде створено package.json зі значеннями за замовчуванням. Щоб встановити ці значення, виконайте в терміналі послідовно наступні команди, підставивши своє ім'я та пошту.

// npm config set init.author.name "YOUR_NAME"
// npm config set init.author.email "YOUR_EMAIL"

// Файл package.json можна редагувати вручну або виконати npm init ще раз. Якщо відкрити package.json в редакторі, він буде виглядати приблизно так. Це всього лише метадані про проект.

//! package.json

// {
//   "name": "node-tut",
//   "version": "1.0.0",
//   "main": "index.js",
//   "scripts": {
//     "test": "echo \\"Error: no test specified\\" && exit 1"
//   },
//   "author": "Alexander Repeta <mycoolemail@mail.com>",
//   "license": "ISC",
//   "keywords": [],
//   "description": ""
// }

//! npm-скрипти

// Скрипти дозволяють запускати для виконання встановлені пакети. Використовуючи npm-скрипти, можна створювати цілі системи збирання проекту. Автоматизуємо запуск index.js. Для цього у файлі package.json в полі scripts додамо скрипт запуску start.

// package.json
// {
// "scripts": {
// "start": "node index.js"
// }
// }

// Тепер ми можемо запустити його в терміналі командою npm start.

//! УВАГА
// Якщо створити скрипт з будь-яким іншим ім'ям, крім start або test, він буде запускатися як npm run ім'я-скрипта - не забудьте run. Ознайомтесь з документацією - How npm handles the "scripts" field.

//! Встановлення пакетів

// Одна из возможностей, которые предоставляет npm - установка пакетов, которые извлекаются из реестра и распаковываются в папку node_modules в корне проекта. После того как файл package.json создан, можно добавить зависимости в проект.

// Зависимостью называют npm-пакет, который используется при разработке. Это всевозможные утилиты и библиотеки. Установим библиотеку validator.js для валидации строк, например ввода пользователя в поля формы.

// npm install validator

// NPM загрузил validator и поместил его в node_modules - папку, в которой будут находиться все внешние зависимости.

//! ВНИМАНИЕ
// Не добавляйте папку node_modules в систему контроля версий, у всех разработчиков она будет своя. Если вы используете Git, не забывайте добавить папку node_modules в файл .gitignore.

// Обратите внимание на созданный файл package-lock.json - это журнал снимков дерева зависимостей проекта. Он гарантирует, что команда разработчиков использует одни и те же версии зависимостей. NPM автоматически обновляет его при добавлении, удалении и обновлении пакетов.

// В package.json появилась новая зависимость в поле dependencies. Это означает, что validator версии 11.1.0 был установлен как зависимость и готов к работе. Пакеты постоянно обновляются, ваша версия может отличаться.

// package.json
// {
// "dependencies": {
// "validator": "^11.1.0"
// }
// }

// Для того чтобы получить интерфейс пакета в Node.js-коде, необходимо вызвать функцию require("имя-модуля"), аргументом передав ей имя модуля без определения пути - это называется абсолютный импорт. Путь не нужен, так как по умолчанию поиск модуля будет происходить в папке node_modules. Результатом своего выполнения функция вернет интерфейс модуля - объект с методами или просто функцию, зависит от пакета.

// index.js
const validator = require('validator');

const validateEmail = email => {
  return validator.isEmail(email);
};

console.log('Is mango@mail.com a valid email?: ', validateEmail('mango@mail.com'));

console.log('Is Mangozedog.com a valid email?: ', validateEmail('Mangozedog.com'));

// Выполнив в терминале npm start получим.

// Is mango@mail.com a valid email?: true
// Is Mangozedog.com a valid email?: false

//! Удаление пакетов

// Предположим, что установленная в предыдущем примере версия validator вызывает проблемы с совместимостью. Мы можем удалить этот пакет и поставить более старую версию.

// npm uninstall validator

//! Установка определенной версии пакета

// Теперь установим нужную версию validator. В команде установки номер версии указывается после символа @.

// npm install validator@1.0.0

// npm install validator@1.0.0

//! ИНТЕРЕСНО
// Установка пакетов определенный версии используется в коммерческих проектах для того, чтобы гарантировать работу кодовой базы и возможность долгосрочной поддержки. Вы можете устанавливать самые последние версии.

//! Типы зависимостей

// Представьте торт, для его приготовления шефу нужны продукты, именно они войдут в состав торта. Но для приготовления понадобятся и инструменты вроде мисок, ложек, лопаток и т. п. А еще на кухне есть столы и печи, холодильники и т. д. - то, что используется для приготовления любого блюда, общие инструменты которые есть на кухне.

// То же самое и с зависимостями проекта - некоторые будут использованы в результирующем продукте, другие необходимы только на стадии разработки, а есть такие, что необходимо использовать вне зависимости от проекта.

// Именно для этого у команд npm install и npm uninstall есть три флага.

// --save - указывает, что добавляется зависимость, которая войдет в финальный продукт. Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле dependencies в package.json.
// --save-dev - указывает, что добавляется зависимость разработки. Пакет будет установлен локально, в папку node_modules, и будет добавлена запись в поле devDependencies в package.json.
// --global - указывает, что добавляется глобальная зависимость, то есть инструмент, который доступен для любого проекта. Пакет будет установлен глобально (в систему).

//! ИНТЕРЕСНО
// Если не указывать флаг, по умолчанию будет использован --save.
// При удалении пакета необходимо указывать правильный флаг, такой же как при установке.
// Не устанавливайте пакеты глобально если вы работаете на проекте с другими разработчиками.

//! Управление версиями пакетов

// Пакеты имеют связанный с ними номер версии. Номера версий соответствуют стандарту SemVer.

// npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно.
// npm update - обновит все пакеты до максимально разрешенной версии.
// npm update [имя-пакета] - обновит указанный пакет.

//! ИНТЕРЕСНО
// Если вы не доверяете машинам или хотите какую-то определённую версию пакета, можно открыть package.json и вручную поменять версии пакетов, после чего выполнить npm install.

//! Управление кэшем

// После установки пакета npm сохраняет его копию в кэше, поэтому при следующей его установке вам не нужно опять скачивать его из интернета. Кэш хранится в папке .npm вашего домашнего каталога.

// Эта папка со временем засоряется старыми пакетами и иногда ее полезно очищать, не слишком часто (пару раз в год), кеширование полезно, так как сокращает время установки уже использованных пакетов.

// npm cache clean

//! Модульність коду

// Концепція модулів як способу організації коду існувала давно. Зі збільшенням проекту і його кодової бази, її намагаються розбити на файли, у кожному з яких описується окремий функціонал.

// Модульний код допомагає в організації, обслуговуванні, тестуванні і, найголовніше, управлінні залежностями. Найважливіші переваги модулів - це підтримка, простір імен і повторне використання.

// Підтримка - добре розроблений модуль, покликаний максимально зменшити залежність від інших частин коду. Це дозволить розширювати функціонал застосунку, не побоюючись порушити його роботу в цілому. Оновлення одного модуля набагато простіше, якщо модуль - самодостатній.

// Простір імен - змінні, що не входять в область видимості функції, є глобальними. Внаслідок цього, як правило, відбувається забруднення простору імен, де повністю непов'язаний код розділяє глобальні змінні. Модулі дозволяють уникнути забруднення простору імен, створюючи окрему область видимості для змінних.

// Повторне використання - усі розробники копіювали готовий код у нові проекти, змінюючи його під специфіку проекту. Це, очевидно, величезна трата часу. Набагато краще, коли є модуль, який можна повторно використовувати знову і знову, без необхідності знати що-небудь про оточення, в якому він використовується.

//! Збирання модулів

// Збирання модулів - це процес конкатенації групи модулів і їх залежностей в один або групу файлів.

// Зазвичай код ділять на папки і файли, до того ж необхідно підключити зовнішні бібліотеки. В результаті кожен з цих файлів потрібно додати в основний HTML-файл в тезі <script>, який потім завантажується браузером.

// Наявність окремих тегів <script> для кожного файлу означає, що браузер буде завантажувати кожен файл окремо, що негативно позначається на швидкості завантаження сторінки. Щоб обійти цю проблему, файли об'єднуються в один або пару файлів з метою зменшення кількості запитів. Але залишається проблема управління залежностями між модулями.

// Якщо використовуються системи модулів, такі як CommonJS або ESM, необхідно використовувати інструмент для їх перетворення у правильно впорядкований і доступний для браузера код. Саме тут починають діяти Webpack та інші бандлери (від англійського bundle).

//! ECMAScript Modules (ESM)

// Донедавна в мові не було вбудованої модульної системи. ESM мають компактний декларативний синтаксис і можливість асинхронного завантаження. ES-модуль - це фрагмент JS-коду, що використовується багато раз та експортує певні об'єкти, роблячи їх доступними для інших модулів.

//* greeter.js

const helloMessage = 'hello!';
const goodbyeMessage = 'goodbye!';

export const hello = () => helloMessage;
export const goodbye = () => goodbyeMessage;

//* index.js

import { hello, goodbye } from './greeter';

console.log(hello()); // "hello!"
console.log(goodbye()); // "goodbye!"

// Кожен JS-файл зберігає код в унікальному контексті модуля та імпортує необхідні йому залежності, і експортує все, що інші модулі повинні імпортувати. Операції експорту/імпорту реалізовані конструкціями import і export. Є дві очевидні переваги цього підходу - запобігання забрудненню глобального простору імен і явне зазначення залежностей.

// Нова система модулів відрізняється від CommonJS та інших, перш за все тим, що це стандарт. А значить, з часом, буде повністю підтримуватися браузерами нативно, без додаткових інструментів. Однак, зараз браузерна підтримка - неповна, тому ESM використовуються разом з інструментами збірки модулів, такими як Webpack, Parcel та іншими.

//? ЦІКАВО
// ESM розроблені з урахуванням статичного аналізу. Це означає, що під час імпорту модулів, імпорт обробляється під час компіляції, тобто до запуску скрипту. Це дозволяє видаляти експорт, який не використовується іншими модулями, перш ніж запускати скрипт, що може призвести до значної економії ваги JS-файлу, зменшивши навантаження на браузер. Це називається tree shaking і виконується бандлерами автоматично під час збирання JS коду.

//! Named export

// Модуль може експортувати декілька сутностей, які відрізняються своїми іменами і називаються іменованими експортами. Щоб імпортувати їх в інший модуль, необхідно знати імена експортованих сутностей, які ми хочемо імпортувати.

// Перший спосіб - це використовувати ключове слово export перед усіма сутностями, які необхідно експортувати. Вони будуть додані як властивості в експортований об'єкт. Під час імпорту ми деструктуризуємо властивості з імпортованого об'єкта.

//* my-module.js
const sqrt = Math.sqrt;
export const square = x => x * x;
export const diag = (x, y) => sqrt(square(x) + square(y));

//*main.js
import { square, diag } from './path/to/my-module';

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

// Другий спосіб - це явно вказати об'єкт з властивостями для експорту.

//*my-module.js
const sqrt = Math.sqrt;
const square = x => x * x;
const diag = (x, y) => sqrt(square(x) + square(y));

export { square, diag };

//*main.js
import { square, diag } from './path/to/myModule';

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

// Наступний синтаксис імпортує всі експорти модуля як об'єкт із зазначеним ім'ям. Це називається namespace import.

//*main.js

import * as myModule from './path/to/my-module';

console.log(myModule.square(11)); // 121
console.log(myModule.diag(4, 3)); // 5

//! Default export

// Часто модуль експортує всього одну сутність - такий експорт зручний для імпорту. Експорт за замовчуванням - найголовніше експортоване значення, яке може бути чим завгодно: змінною, функцією, класом тощо.

//*my-func.js
export default function myFunc() {
  // ...
}

//*my-class.js
export default class MyClass {
  // ...
  }


  //* main.js

  import myFunc from "./path/to/my-func";
  import MyClass from "./path/to/my-class";

  myFunc();

  const inst = new MyClass();

  // Використовуйте іменований експорт, якщо необхідно експортувати декілька сутностей, а експорт за замовчуванням - для експорту однієї сутності. Хоча і можливо використовувати експорт за замовчуванням та іменований експорт в одному файлі, хорошою практикою буде вибрати тільки один стиль для кожного модуля.
