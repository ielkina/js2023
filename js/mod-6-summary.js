console.log('module 6 summary');
/**
 * Объектная модель документа
 */
// Объектная модель документа(Document Object Model) - независимый от языка интерфейс для работы с HTML - документом.Содержит набор свойств и методов позволяющих искать, создавать и удалять элементы, реагировать на действия пользователя и многое другое.То есть соединяет страницу с языком программирования.

// DOM это отражение HTML - документа - древовидная структура, в которой каждый узел это JavaScript - объект со свойствами и методами, представляющий часть HTML - документа.Каждый элемент в документе, весь документ в целом, заголовок, ссылка, абзац - это части DOM этого документа, поэтому все они могут быть изменены из JavaScript - кода.

// Объектная модель браузера(Browser Object Model) - независимый от языка интерфейс для работы с вкладкой браузера.Содержит набор свойств и методов, позволяющих получить доступ непосредственно к текущей вкладке и ряду функций браузера.Включает объект работы с историей навигации, местоположением и многое другое.

// У движка браузера есть специальный фрагмент кода - HTML - парсер, который используется для преобразования HTML в DOM.

//Сервис генератора DOM-дерева
// https://software.hixie.ch/utilities/js/live-dom-viewer/

// Узлы - элементы(element node) - образуются тегами, естественным образом одни элементы вложены в другие.Структура дерева образована исключительно за счет них.
// Текстовые узлы(text node) - образуются текстом внутри элементов.Текстовый узел содержит только строку текста и не может иметь потомков, то есть он всегда на самом нижнем уровне иерархии.Пробелы и переносы строк - это тоже текстовые узлы.

// Из этого правила есть исключения: пробелы до head игнорируются, а любое содержимое после body не создаёт элемент, браузер переносит его в конец body.

/**Навигация по DOM */

//Доступ к DOM начинается с объекта document, от него можно добраться до любых элементов.

//document это часть глобального объекта window, который доступен в скрипте, когда он выполняется в браузере. Также как alert, console.log, prompt и многие другие.

//Элементы DOM-дерева имеют иерархическое отношение друг к другу. Для описания отношений используются термины предок (ancestor), потомок (descendant), родитель (parent), ребенок (child) и сосед (sibling).

// Самый верхний элемент называется корневым(root node).
// Каждый элемент, кроме корневого, имеет только одного родителя.
// У элемента может быть сколько угодно детей.
// Соседи - это элементы с общим родителем.
// Дочерние элементы(дети) - элементы, которые лежат непосредственно внутри текущего(первая вложенность).
// Потомки – все элементы, которые лежат внутри текущего, вместе с их детьми, детьми их детей и так далее.То есть всё поддерево.

// DOM traversal
// Для навигации по этой иерархии у элементов есть следующие свойства.

// elem.parentNode - выберет родителя elem.
// elem.childNodes - псевдомассив, хранит все дочерние элементы, включая текстовые.
// elem.children - псевдомассив, хранит только дочерние узлы - элементы, то есть соответствующие тегам.
// elem.firstChild - выберет первый дочерний элемент внутри elem, включая текстовые узлы.
// elem.firstElementChild - выберет первый дочерний узел - элемент внутри elem.
// elem.lastChild - выберет последний дочерний элемент внутри elem, включая текстовые узлы.
// elem.lastElementChild - выберет последний дочерний узел - элемент внутри elem.
// elem.previousSibling - выберет элемент «слева» от elem(его предыдущего соседа).
// elem.previousElementSibling - выберет узел - элемент «слева» от elem(его предыдущего соседа).
// elem.nextSibling - выберет элемент «справа» от elem(его следующего соседа)
// elem.nextElementSibling - выберет узел - элемент «справа» от elem(его следующего соседа).

// https://codepen.io/goit-academy/pen/oNZqxoP

// DOM - коллекции, такие как childNodes и children - псевдомассивы(NodeList), у них нет большинства методов массива.

/***Поиск элементов */

//  Группа методов elem.querySelector * это современный стандарт для поиска элементов.Они позволяют найти элемент или группу элементов по CSS - селектору любой сложности.

// Возвращает первый найденный элемент внутри element, соответствующий CSS - селектору selector.
// Если ничего не найдено, вернет null.

// element.querySelector(selector);
// element.querySelectorAll(selector);

// https://codepen.io/goit-academy/pen/wvJmGbG

/**Свойства и атрибуты */

// value - содержит текущий текстовый контент элементов форм.
// checked - хранит состояние чекбокса или радиокнопки.
// name - хранит значение, указанное в HTML - атрибуте name.
// src - путь к изображению тега < img >.

// https://codepen.io/goit-academy/pen/poeLbbd

/**Свойство textContent */

// elem.textContent возвращает текстовый контент внутри элемента.Доступно для чтения и записи.Не зависимо что будет передано в textContent, данные всегда будут записаны как текст.

// https://codepen.io/goit-academy/pen/wvJmWqd

/**Свойство classList */

// В свойстве classList хранится объект с методами для работы с классами элемента.

// elem.classList.contains(cls) - возвращает true или false в зависимости от того, есть ли у элемента класс cls.
// elem.classList.add(cls) - добавляет класс cls в список классов элемента.
// elem.classList.remove(cls) - удаляет класс cls из списка классов элемента.
// elem.classList.toggle(cls) - если класса cls нет, то добавляет его, если есть, наоборот удаляет.
// elem.classList.replace(oldClass, newClass) - заменяет существующий класс oldClass на указанный newClass.

// https://codepen.io/goit-academy/pen/qBroNyW

/**Свойство style */

// Используется для чтения и изменения инлайновых стилей. Возвращает объект CSSStyleDeclaration, который содержит список всех свойств, определенных только во встроенных стилях элемента, а не весь CSS. При записи свойства записываются в camelCase, то есть background-color превращается в element.style.backgroundColor и т. д.

/*const button = document.querySelector(".btn");

// button.style.backgroundColor = "teal";
// button.style.fontSize = "24px";
// button.style.textAlign = "center";

// console.log(button.style); // inline styles object*/

// На практике стилизация элементов выполняется добавленим CSS - классов.Свойство style используется для добавления каких - то динамических стилей, например во время анимации.

/*Атрибуты*/

// DOM - элементам соответствуют HTML - теги у которых есть текстовые атрибуты.Доступ к атрибутам осуществляется при помощи стандартных методов.Эти методы работают со значением, которое находится в HTML.

// elem.hasAttribute(name) - проверяет наличие аттрибута, возвращает true или false.
// elem.getAttribute(name) - получает значение атрибута и возвращает его.
// elem.setAttribute(name, value) - устанавливает атрибут.
// elem.removeAttribute(name) - удаляет атрибут.
// elem.attributes - свойство, возвращает объект всех атрибутов элемента.

// https://codepen.io/goit-academy/pen/VwpXjga

/**data-атрибуты */

// Позволяют добавить тегу произвольный атрибут и получить его значение в JavaScript.Эту возможность используют для того, чтобы упростить написание кода, например связать данные и разметку по уникальному идентификатору, указать тип действия кнопки и т.п.

/*<button type="button" data-action="save">Save</button>
<button type="button" data-action="close">Close</button>*/

// Для получения значения data - атрибута используется свойство dataset, после которого идет имя атрибута.То есть data - отбрасывается, а остальное имя записывается как имя свойства объекта.

/*const saveBtn = document.querySelector('button[data-action="save"]');
console.log(saveBtn.dataset.action); // "save"

const closeBtn = document.querySelector('button[data-action="close"]');
console.log(closeBtn.dataset.action); // "close"*/

// https://codepen.io/goit-academy/pen/vYxRXYg

/**Создание и удаление элементов */

//Создание

/*document.createElement(tagName);

const heading = document.createElement("h1");
console.log(heading); // <h1></h1>

heading.textContent = "This is a heading";
console.log(heading); // <h1>This is a heading</h1>

const image = document.createElement("img");
image.src = "https://placeimg.com/640/480/nature";
image.alt = "Nature";
console.log(image); // <img src="https://placeimg.com/640/480/nature" alt="Nature" />*/

//Добавление

//Методы

// element.append(el1, el2, ...) - добавляет один или несколько элементов после всех детей элемента element.
// element.prepend(el1, el2, ...) - добавляет один или несколько элементов перед всеми детьми элемента element.
// element.after(el1, el2, ...) - добавляет один или несколько элементов после элемента element.
// element.before(el1, el2, ...) - добавляет один или несколько элементов перед элементом element.

// https://codepen.io/goit-academy/pen/WNpzoZQ

// Если элемент для вставки уже находится в DOM, то он изымается из своего старого места и добавляется в новое. Отсюда вытекает правило - один и тот же элемент не может быть одновременно в двух местах.

//Удаление

/**elem.remove(); */

/**Оптимизация работы с DOM */

// Repaint - происходит, когда изменения затронули стили влияющие на внешний вид элемента, но не на геометрию.Например opacity, background - color, visibility и outline.Браузер отрисовывает элемент заново, с учётом нового стиля.Также проверяется видимость других элементов, один или более могут оказаться скрыты под изменившим внешний вид.

// Reflow - происходит когда изменения затрагивают содержимое, структуру документа, положение элементов.Идет пересчет позиционирования и размеров, что ведет к перерисовке части или всего документа.Изменение размера одного родительского контейнера повлияет на всех его детей и предков.Имеет значительно большее влияние на производительность, чем repaint.

// Все вышеперечисленные операции блокируют браузер.Страница не может выполнять никакие другие операции в то время, когда происходит reflow или repaint.Причинами могут быть:

// Манипуляции с DOM(добавление, удаление, изменение, перестановка элементов)
// Изменение содержимого, в т.ч.текста в полях форм
// Расчёт или изменение CSS - свойств
// Добавление и удаление таблиц стилей
// Манипуляции с атрибутом class
// Манипуляции с окном браузера(изменения размеров, прокрутка)
// Активация псевдоклассов(например : hover)

/**Свойство innerHTML */

//Чтение

// Свойство innerHTML хранит содержимое элемента, включая теги, в виде строки.Возвращаемое значение это всегда валидный HTML - код.

// https://codepen.io/goit-academy/pen/ZEeRegd

//Изменение

// Свойство innerHTML доступно как для чтения, так и для записи.Если записать в него строку с HTML - тегами, то браузер во время парсинга строки превратит их в валидные элементы и добавит в DOM - дерево.

// https://codepen.io/goit-academy/pen/JjWZNKb

// Если в свойство innerHTML записать пустую строку, то содержимое элемента будет очищено.Это простой и быстрый способ удаления всего содержимого.

// При таком подходе, в отличии от document.createElement(), мы не получаем ссылку на созданный DOM - элемент.Это первый шаг на пути к шаблонизации - создания большого количества однотипной разметки с разными данными по заранее определённому шаблону.Например, как в списке товаров интернет магазина и т.п.

// Однотипная(шаблонная) разметка создается из массива данных.Приём заключается в переборе этого массива и составлении одной строки с HTML тегами, которую потом записываем в innerHTML элемента.

// https://codepen.io/goit-academy/pen/qBrKmJP

//Добавление

// Изменение elem.innerHTML полностью удалит и пересоздаст всех потомков элемента elem.Если элемент изначально не пустой, то будут дополнительные затраты на сериализацию уже существующей разметки, а это плохо.

// https://codepen.io/goit-academy/pen/QWpxvqR

// Используйте свойство elem.innerHTML для добавления только в случае когда элемент elem пустой или если надо полностью заменить его содержимое.

/**Метод insertAdjacentHTML() */

// elem.insertAdjacentHTML(position, string);

// Аргумент position - это строка, позиция относительно элемента elem.Принимает одно из четырёх значений.

// "beforebegin" - перед elem
// "afterbegin" - внутри elem, перед всеми детьми
// "beforeend" - внутри elem, после всех детей
// "afterend" - после elem

// https://codepen.io/goit-academy/pen/mdWKMOE

// "beforebegin" и "afterend" работают только в том случае, если elem уже находится в DOM - дереве.

/**
 * Подключение скриптов
 */

//<script src="path-to-script.js"></script>

// Когда анализатор встречает такой тег, обработка HTML-документа приостанавливается и начинается загрузка файла скрипта указанного в атрибуте src. После загрузки скрипт выполняется, и только потом возобновляется обработка HTML. Это называется «блокирующий» скрипт.

// Атрибуты defer и async были введены чтобы дать разработчикам возможность лучше контролировать как загружать скрипты и когда именно их выполнять.

/**Атрибут defer */

//<script defer src="path-to-script.js"></script>;

//Атрибут defer указывает браузеру загружать файл скрипта в фоновом режиме, паралельно обработке HTML-документа и построению DOM. Скрипт будет выполнен только после того как HTML-документ обработан, а DOM построен. Такие скрипты не блокируют построение DOM-дерева и гарантированно выполняются в том порядке, в котором указаны в HTML-документе.

//HTML  building DOM... done!
//JS  script fetch   execution

/**Атрибут async */

//<script async src="path-to-script.js"></script>

//Загрузка скрипта с атрибутом async не блокирует построение DOM, но он выполняется сразу после загрузки. Это значит, что такие скрипты могут заблокировать построение DOM, и выполняются в произвольном порядке.

//HTML  building DOM... blocked   building DOM...
//JS script fetch execution

/**События */

// Одно действие может вызывать несколько событий.Например, клик вызывает сначала mousedown, а затем mouseup и click.В тех случаях, когда одно действие генерирует несколько событий, их порядок фиксирован.То есть, обработчики вызовутся в порядке mousedown → mouseup → click.

/** Метод addEventListener()*/

// Добавляет слушателя события на элемент.

// element.addEventListener(event, handler, options);

// event - имя события, строка, например "click".
// handler - коллбэк - функция которая будет вызвана при наступлении события.
// options - необязательный объект параметров с расширенными настройками.

// const button = document.querySelector(".my-button");

// button.addEventListener("click", () => {
// console.log("Button was clicked");
// });

// Для коллбэка можно(и желательно) использовать отдельную функцию и передавать на неё ссылку.Именованная функция повышает читаемость кода.

// const button = document.querySelector(".my-button");

// const handleClick = () => {
//   console.log("Button was clicked");
// };

// button.addEventListener("click", handleClick);

// На одном элементе может быть сколько угодно обработчиков событий, даже событий одного типа.Коллбэк - функции будут вызываться в порядке регистрации их в коде.

// https://codepen.io/goit-academy/pen/QWpxOvE

/**Метод removeEventListener() */

// element.removeEventListener(event, handler, options);

// Для удаления нужно передать ссылку именно на ту коллбэк - функцию, которая была назначена в addEventListener().В таком случае для коллбэков используют отдельную функцию и передают её по имени(ссылку).

// https://codepen.io/goit-academy/pen/vYxrWpw

/**Ключевое слово this */

// Если коллбэком будет функция которая использует this, по умолчанию контекст внутри неё будет ссылаться на DOM - элемент на котором висит слушатель.

// const mango = {
//   username: "Mango",
//   showUsername() {
//     console.log(this);
//     console.log(`My username is: ${this.username}`);
//   },
// };

// const btn = document.querySelector(".js-btn");

// // ✅ Работает
// mango.showUsername();

// // ❌ this будет ссылаться на button если использовать showUsername как callback
// btn.addEventListener("click", mango.showUsername); // не работает

// // ✅ Не забывайте привязывать контекст методов объекта
// btn.addEventListener("click", mango.showUsername.bind(mango));

/**Объект события */

// Каждое событие представляет собой объект, который содержит информацию о деталях события и автоматически передается первым аргументом в обработчик события.Все события происходят от базового класса Event.

// const handleClick = event => {
//   console.log(event);
// };

// button.addEventListener("click", handleClick);

// event.type - тип события.
// event.currentTarget - элемент, на котором выполняется обработчик события.

// https://codepen.io/goit-academy/pen/MWpXraG

/*Действия браузера по умолчанию*/

// https://codepen.io/goit-academy/pen/wvJXprr

/**События клавиатуры */

// Есть два основных события клавиатуры: keydown и keyup.В отличии от других, события клавиатуры обрабатываются на документе, а не на конкретном элементе.Объекты событий клавиатуры происходят от базового класса KeyboardEvent.

// document.addEventListener("keydown", event => {
//   console.log("Keydown: ", event);
// });

// document.addEventListener("keyup", event => {
//   console.log("Keyup: ", event);
// });

// Раньше было еще одно событие клавиатуры - keypress.Многие посты на форумах и блогах по - прежнему могут его использовать, но будьте осторожны - оно устарело и поддержка в новых браузерах может прекратиться в любой момент.

/**Свойства key и code */

// Свойство key возвращает символ сгенерированный нажатием клавиши, принимая во внимание состояние клавиш модификаторов, например Shift, а так же текущий язык.Свойство code возвращает код физической клавиши на клавиатуре и не изменяется между языками.

// document.addEventListener("keydown", event => {
//   console.log("key: ", event.key);
//   console.log("code: ", event.code);
// });

// https://codepen.io/goit-academy/pen/ZEeRxaJ

/**Клавиши-модификаторы */

// Для обработки комбинации клавиш, например Ctrl + s или любую другую, на объекте события есть свойства ctrlKey, altKey, shiftkey и metaKey, хранящие булевое значение сигнализирующее о том, была зажата клавиша - модификатор или нет.

// document.addEventListener("keydown", event => {
//   event.preventDefault();

//   if ((event.ctrlKey || event.metaKey) && event.code === "KeyS") {
//     console.log("«Ctrl + s» or «Command + s» combo");
//   }
// });

// Некоторые комбинации клавиш могут конфликтовать с поведением браузера по умолчанию.Например, Ctrl + d или Command + d делает закладку.Нужно стараться проектировать систему комбинаций страницы так, чтобы она не пересекалась со встроенной в браузер.Но, в крайнем случае, поведение по умолчанию можно отменить вызвав метод event.preventDefault().

// Не так давно, вместо свойств key и code использовали свойство keyCode.Многие посты на форумах и блогах по - прежнему могут использовать его, но будьте осторожны - оно устарело, не используйте свойство keyCode.

/**События элементов форм */

/**Событие submit */

// Отправка формы происходит при клике по кнопке с атрибутом type = "submit" или нажатии клавиши Enter, находясь в каком - нибудь её текстовом поле.Событие submit можно применить для валидации(проверки) формы перед отправкой, так как на объекте события есть много полезных свойств связанных с элементами формы.Сабмит формы перезагружает страницу, поэтому не забывайте отменять действие по умолчанию методом preventDefault().

// https://codepen.io/goit-academy/pen/oNZydVL

// Свойство elements DOM - элемента формы содержит обьект со ссылками на все её элементы у которых есть атрибут name.Поэтому в примере мы получаем значение полей обращаясь к login.value и password.value.

/**Событие change */

// Происходит после изменения элемента формы.Для текстовых полей или textarea событие произойдёт не при каждом вводе символа, а при потере фокуса, что не всегда удобно.Например, пока вы набираете что - то в текстовом поле - события нет, но как только фокус пропал, произойдет событие change.Для остальных элементов, например select, чекбоксов и радио - кнопок, событие change срабатывает сразу при выборе значения.

// https://codepen.io/goit-academy/pen/gOmKKvj

// Обратите внимание на полезные свойства при работе с элементом < select > в примере.Разберитесь что хранится в свойствах value, selectedIndex и options.

/**Событие input */

// Происходит только на текстовых полях и textarea, и создаётся каждый раз при изменении значения элемента, не дожидаясь потери фокуса.На практике input это самое главное событие для работы с текстовыми полями формы.

// https://codepen.io/goit-academy/pen/jOBKpNP

/**События focus и blur */

// Элемент получает фокус при клике мыши или переходе клавишей Tab.Момент получения фокуса и потери очень важен, при получении фокуса мы можем подгрузить данные для автозаполнения, начать отслеживать изменения и т.п.При потере фокуса - проверить введённые данные.

// При фокусировке элемента происходит событие focus, а когда фокус исчезает, например пользователь кликает в другом месте экрана, происходит событие blur.Активировать или отменить фокус можно программно, вызвав в коде одноименные методы focus() и blur() у элемента.

// https://codepen.io/goit-academy/pen/JjWZBdM

// Фокус может быть только на одном элементе страницы в единицу времени и текущий элемент, на котором фокус, доступен как document.activeElement.

// Многие элементы не могут получить фокус.Например, если кликнуть по < div >, то фокусировка на нем не произойдет, потому что это не интерактивный элемент.