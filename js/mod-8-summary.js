//! Node.js
// Node.js - легке та ефективне середовище виконання JavaScript. Дозволяє писати високопродуктивні серверні застосунки та інструменти. Node.js побудована на JavaScript-рушію V8 і написана на C++.

// Спочатку Node.js створювалася як серверне оточення для застосунків, але розробники почали використовувати її для створення інструментів, які допомагають автоматизувати виконання локальних завдань. В результаті нова екосистема інструментів, яка виникла навколо Node.js, призвела до трансформації процесу фронтенд-розробки.

// Встановлення

// Щоб встановити останню стабільну версію, перейдіть на офіційну сторінку, завантажте LTS-інсталятор і дотримуйтесь вказівок. Існують інсталятори для всіх популярних операційних систем - Windows, MacOS і Linux.

//! ЦІКАВО
// Користувачам Windows необхідно вибрати чекбокси для встановлення всіх додаткових інструментів, крім Chocolatey. Це встановить Python і різноманітні допоміжні утиліти і компілятори.

// Після встановлення в терміналі буде доступна команда node. Щоб переконатися, що встановлення пройшло успішно, перевірте версію, запустивши в консолі команду node з прапорцем version.

// node --version

//! JavaScript поза браузером

// Node.js дозволяє виконувати JavaScript-код поза браузером. Відкрийте будь-який термінал і виконайте команду node, запуститься REPL (read-eval-print loop) - інтерактивне середовище виконання JS-коду. Виведемо щось в консоль.

//! ЦІКАВО
// Для того, щоб вийти з REPL, натисніть комбінацію Ctrl + C на Windows і Control + C на MacOS.

// Тепер створимо папку node-tut, а в ній - файл index.js з кодом, який ми писали в REPL. Для запуску потрібно відкрити термінал і перейти в папку node-tut, в якій лежить index.js.

// index.js
const message = 'NodeJS in amazing!';
console.log(message);

// Тепер в консолі запускаємо файл за допомогою команди node index.js і отримуємо такий самий результат - виведення рядка безпосередньо в терміналі.

// В цьому і полягає суть Node.js - можливість виконувати JavaScript поза браузером. Таким чином можна писати цілі застосунки, наприклад, бекенд або утиліти, що не залежать від браузера.

//! Пакетний менеджер npm

// Щоб використовувати все різноманіття інструментів (або пакетів) Node.js, нам необхідна можливість встановлювати і керувати ними. Для цього створений NPM (node package manager) - пакетний менеджер Node.js. Він встановлює потрібні пакети і забезпечує зручний інтерфейс для роботи з ними.

// NPM складається з трьох основних компонентів:

// Сайт npmjs.com - використовується для пошуку та ознайомлення з документацією пакетів.

// Інтерфейс командного рядка (CLI) - запускається з терміналу і надає набір команд для роботи з реєстром і пакетами. Дозволяє створювати скрипти для запуску в терміналі.

// Реєстр пакетів (registry) - велика загальнодоступна база даних інструментів розробки (пакетів).

// Пакет (package) - невелика JavaScript бібліотека, що вирішує специфічне завдання. Пакети пишуть самі розробники і діляться зі спільнотою. Такий підхід спрощує життя, тому що не потрібно винаходити колесо, всі колеса вже давно лежать на полицях реєстру і готові до використання.

//! ЦІКАВО
// Пакети абстрагують реалізацію функціоналу, надаючи розробнику зручний інтерфейс. Це робить код чистішим, читабельнішим і дозволяє простіше його підтримувати.

//! Команди NPM

// Відразу перелічимо основні команди і будемо послідовно використовувати і розглядати в деталях.

// npm init - ініціалізує npm в проекті і створює файл package.json
// npm install - встановлює всі залежності, перелічені в package.json
// npm list --depth=0 - виведе в терміналі список локально встановлених пакетів з номерами їх версій, без залежностей
// npm install [package-name] - встановить пакет локально у папку node_modules
// npm uninstall [package-name] - видалить пакет, встановлений локально і оновить package.json
// npm start і npm test - запустить скрипт start або test, розташований в package.json
// npm run [custom-script] - запустить кастомний скрипт, розташований в package.json
// npm outdated - використовується для пошуку оновлень, виявить сумісні версії програмно і виведе список доступних оновлень
// npm update - оновить всі пакети до максимально дозволеної версії

// https://docs.npmjs.com/

//! Ініціалізація проекту

// Кожен проект починається зі створення файлу package.json - він відстежує залежності, містить службову інформацію, дозволяє писати npm-скрипти і слугує інструкцією під час створення нового проекту на основі вже готових налаштувань. Файл package.json можна створити npm-командою init, що ініціалізує проект в цій папці.

// npm init

// Вам буде запропоновано ввести назву проекту, версію, опис тощо. Можна просто натискати Enter доти, доки не буде створений package.json і розміщений в папці проекту. Щоб не натискати Enter, пропускаючи порожні поля, використовується команда init з прапорцем --yes. Прапорець - додаткове налаштування для команди.

// npm init --yes

//! ЦІКАВО
// У кожного прапорця є псевдонім - його скорочений запис. Псевдонім прапорця --yes - -y, тому команди npm init --yes і npm init -y роблять одне і те ж.

// Буде створено package.json зі значеннями за замовчуванням. Щоб встановити ці значення, виконайте в терміналі послідовно наступні команди, підставивши своє ім'я та пошту.

// npm config set init.author.name "YOUR_NAME"
// npm config set init.author.email "YOUR_EMAIL"

// Файл package.json можна редагувати вручну або виконати npm init ще раз. Якщо відкрити package.json в редакторі, він буде виглядати приблизно так. Це всього лише метадані про проект.

//! package.json

// {
//   "name": "node-tut",
//   "version": "1.0.0",
//   "main": "index.js",
//   "scripts": {
//     "test": "echo \\"Error: no test specified\\" && exit 1"
//   },
//   "author": "Alexander Repeta <mycoolemail@mail.com>",
//   "license": "ISC",
//   "keywords": [],
//   "description": ""
// }

//! npm-скрипти

// Скрипти дозволяють запускати для виконання встановлені пакети. Використовуючи npm-скрипти, можна створювати цілі системи збирання проекту. Автоматизуємо запуск index.js. Для цього у файлі package.json в полі scripts додамо скрипт запуску start.

// package.json
// {
// "scripts": {
// "start": "node index.js"
// }
// }

// Тепер ми можемо запустити його в терміналі командою npm start.

//! УВАГА
// Якщо створити скрипт з будь-яким іншим ім'ям, крім start або test, він буде запускатися як npm run ім'я-скрипта - не забудьте run. Ознайомтесь з документацією - How npm handles the "scripts" field.

//! Встановлення пакетів

// Одна из возможностей, которые предоставляет npm - установка пакетов, которые извлекаются из реестра и распаковываются в папку node_modules в корне проекта. После того как файл package.json создан, можно добавить зависимости в проект.

// Зависимостью называют npm-пакет, который используется при разработке. Это всевозможные утилиты и библиотеки. Установим библиотеку validator.js для валидации строк, например ввода пользователя в поля формы.

// npm install validator

// NPM загрузил validator и поместил его в node_modules - папку, в которой будут находиться все внешние зависимости.

//! ВНИМАНИЕ
// Не добавляйте папку node_modules в систему контроля версий, у всех разработчиков она будет своя. Если вы используете Git, не забывайте добавить папку node_modules в файл .gitignore.

// Обратите внимание на созданный файл package-lock.json - это журнал снимков дерева зависимостей проекта. Он гарантирует, что команда разработчиков использует одни и те же версии зависимостей. NPM автоматически обновляет его при добавлении, удалении и обновлении пакетов.

// В package.json появилась новая зависимость в поле dependencies. Это означает, что validator версии 11.1.0 был установлен как зависимость и готов к работе. Пакеты постоянно обновляются, ваша версия может отличаться.

// package.json
// {
// "dependencies": {
// "validator": "^11.1.0"
// }
// }

// Для того чтобы получить интерфейс пакета в Node.js-коде, необходимо вызвать функцию require("имя-модуля"), аргументом передав ей имя модуля без определения пути - это называется абсолютный импорт. Путь не нужен, так как по умолчанию поиск модуля будет происходить в папке node_modules. Результатом своего выполнения функция вернет интерфейс модуля - объект с методами или просто функцию, зависит от пакета.

// index.js
const validator = require('validator');

const validateEmail = email => {
  return validator.isEmail(email);
};

console.log('Is mango@mail.com a valid email?: ', validateEmail('mango@mail.com'));

console.log('Is Mangozedog.com a valid email?: ', validateEmail('Mangozedog.com'));

// Выполнив в терминале npm start получим.

// Is mango@mail.com a valid email?: true
// Is Mangozedog.com a valid email?: false

//! Удаление пакетов

// Предположим, что установленная в предыдущем примере версия validator вызывает проблемы с совместимостью. Мы можем удалить этот пакет и поставить более старую версию.

// npm uninstall validator

//! Установка определенной версии пакета

// Теперь установим нужную версию validator. В команде установки номер версии указывается после символа @.

// npm install validator@1.0.0

// npm install validator@1.0.0

//! ИНТЕРЕСНО
// Установка пакетов определенный версии используется в коммерческих проектах для того, чтобы гарантировать работу кодовой базы и возможность долгосрочной поддержки. Вы можете устанавливать самые последние версии.

//! Типы зависимостей

// Представьте торт, для его приготовления шефу нужны продукты, именно они войдут в состав торта. Но для приготовления понадобятся и инструменты вроде мисок, ложек, лопаток и т. п. А еще на кухне есть столы и печи, холодильники и т. д. - то, что используется для приготовления любого блюда, общие инструменты которые есть на кухне.

// То же самое и с зависимостями проекта - некоторые будут использованы в результирующем продукте, другие необходимы только на стадии разработки, а есть такие, что необходимо использовать вне зависимости от проекта.

// Именно для этого у команд npm install и npm uninstall есть три флага.

// --save - указывает, что добавляется зависимость, которая войдет в финальный продукт. Пакет будет установлен локально, в папку node_modules и будет добавлена запись в поле dependencies в package.json.
// --save-dev - указывает, что добавляется зависимость разработки. Пакет будет установлен локально, в папку node_modules, и будет добавлена запись в поле devDependencies в package.json.
// --global - указывает, что добавляется глобальная зависимость, то есть инструмент, который доступен для любого проекта. Пакет будет установлен глобально (в систему).

//! ИНТЕРЕСНО
// Если не указывать флаг, по умолчанию будет использован --save.
// При удалении пакета необходимо указывать правильный флаг, такой же как при установке.
// Не устанавливайте пакеты глобально если вы работаете на проекте с другими разработчиками.

//! Управление версиями пакетов

// Пакеты имеют связанный с ними номер версии. Номера версий соответствуют стандарту SemVer.

// npm outdated - используется для поиска обновлений, обнаружит совместимые версии программно.
// npm update - обновит все пакеты до максимально разрешенной версии.
// npm update [имя-пакета] - обновит указанный пакет.

//! ИНТЕРЕСНО
// Если вы не доверяете машинам или хотите какую-то определённую версию пакета, можно открыть package.json и вручную поменять версии пакетов, после чего выполнить npm install.

//! Управление кэшем

// После установки пакета npm сохраняет его копию в кэше, поэтому при следующей его установке вам не нужно опять скачивать его из интернета. Кэш хранится в папке .npm вашего домашнего каталога.

// Эта папка со временем засоряется старыми пакетами и иногда ее полезно очищать, не слишком часто (пару раз в год), кеширование полезно, так как сокращает время установки уже использованных пакетов.

// npm cache clean

//! Модульність коду

// Концепція модулів як способу організації коду існувала давно. Зі збільшенням проекту і його кодової бази, її намагаються розбити на файли, у кожному з яких описується окремий функціонал.

// Модульний код допомагає в організації, обслуговуванні, тестуванні і, найголовніше, управлінні залежностями. Найважливіші переваги модулів - це підтримка, простір імен і повторне використання.

// Підтримка - добре розроблений модуль, покликаний максимально зменшити залежність від інших частин коду. Це дозволить розширювати функціонал застосунку, не побоюючись порушити його роботу в цілому. Оновлення одного модуля набагато простіше, якщо модуль - самодостатній.

// Простір імен - змінні, що не входять в область видимості функції, є глобальними. Внаслідок цього, як правило, відбувається забруднення простору імен, де повністю непов'язаний код розділяє глобальні змінні. Модулі дозволяють уникнути забруднення простору імен, створюючи окрему область видимості для змінних.

// Повторне використання - усі розробники копіювали готовий код у нові проекти, змінюючи його під специфіку проекту. Це, очевидно, величезна трата часу. Набагато краще, коли є модуль, який можна повторно використовувати знову і знову, без необхідності знати що-небудь про оточення, в якому він використовується.

//! Збирання модулів

// Збирання модулів - це процес конкатенації групи модулів і їх залежностей в один або групу файлів.

// Зазвичай код ділять на папки і файли, до того ж необхідно підключити зовнішні бібліотеки. В результаті кожен з цих файлів потрібно додати в основний HTML-файл в тезі <script>, який потім завантажується браузером.

// Наявність окремих тегів <script> для кожного файлу означає, що браузер буде завантажувати кожен файл окремо, що негативно позначається на швидкості завантаження сторінки. Щоб обійти цю проблему, файли об'єднуються в один або пару файлів з метою зменшення кількості запитів. Але залишається проблема управління залежностями між модулями.

// Якщо використовуються системи модулів, такі як CommonJS або ESM, необхідно використовувати інструмент для їх перетворення у правильно впорядкований і доступний для браузера код. Саме тут починають діяти Webpack та інші бандлери (від англійського bundle).

//! ECMAScript Modules (ESM)

// Донедавна в мові не було вбудованої модульної системи. ESM мають компактний декларативний синтаксис і можливість асинхронного завантаження. ES-модуль - це фрагмент JS-коду, що використовується багато раз та експортує певні об'єкти, роблячи їх доступними для інших модулів.

//* greeter.js

const helloMessage = 'hello!';
const goodbyeMessage = 'goodbye!';

export const hello = () => helloMessage;
export const goodbye = () => goodbyeMessage;

//* index.js

import { hello, goodbye } from './greeter';

console.log(hello()); // "hello!"
console.log(goodbye()); // "goodbye!"

// Кожен JS-файл зберігає код в унікальному контексті модуля та імпортує необхідні йому залежності, і експортує все, що інші модулі повинні імпортувати. Операції експорту/імпорту реалізовані конструкціями import і export. Є дві очевидні переваги цього підходу - запобігання забрудненню глобального простору імен і явне зазначення залежностей.

// Нова система модулів відрізняється від CommonJS та інших, перш за все тим, що це стандарт. А значить, з часом, буде повністю підтримуватися браузерами нативно, без додаткових інструментів. Однак, зараз браузерна підтримка - неповна, тому ESM використовуються разом з інструментами збірки модулів, такими як Webpack, Parcel та іншими.

//? ЦІКАВО
// ESM розроблені з урахуванням статичного аналізу. Це означає, що під час імпорту модулів, імпорт обробляється під час компіляції, тобто до запуску скрипту. Це дозволяє видаляти експорт, який не використовується іншими модулями, перш ніж запускати скрипт, що може призвести до значної економії ваги JS-файлу, зменшивши навантаження на браузер. Це називається tree shaking і виконується бандлерами автоматично під час збирання JS коду.

//! Named export

// Модуль може експортувати декілька сутностей, які відрізняються своїми іменами і називаються іменованими експортами. Щоб імпортувати їх в інший модуль, необхідно знати імена експортованих сутностей, які ми хочемо імпортувати.

// Перший спосіб - це використовувати ключове слово export перед усіма сутностями, які необхідно експортувати. Вони будуть додані як властивості в експортований об'єкт. Під час імпорту ми деструктуризуємо властивості з імпортованого об'єкта.

//* my-module.js
const sqrt = Math.sqrt;
export const square = x => x * x;
export const diag = (x, y) => sqrt(square(x) + square(y));

//*main.js
import { square, diag } from './path/to/my-module';

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

// Другий спосіб - це явно вказати об'єкт з властивостями для експорту.

//*my-module.js
const sqrt = Math.sqrt;
const square = x => x * x;
const diag = (x, y) => sqrt(square(x) + square(y));

export { square, diag };

//*main.js
import { square, diag } from './path/to/myModule';

console.log(square(11)); // 121
console.log(diag(4, 3)); // 5

// Наступний синтаксис імпортує всі експорти модуля як об'єкт із зазначеним ім'ям. Це називається namespace import.

//*main.js

import * as myModule from './path/to/my-module';

console.log(myModule.square(11)); // 121
console.log(myModule.diag(4, 3)); // 5

//! Default export

// Часто модуль експортує всього одну сутність - такий експорт зручний для імпорту. Експорт за замовчуванням - найголовніше експортоване значення, яке може бути чим завгодно: змінною, функцією, класом тощо.

//*my-func.js
export default function myFunc() {
  // ...
}

//*my-class.js
export default class MyClass {
  // ...
  }


  //* main.js

  import myFunc from "./path/to/my-func";
  import MyClass from "./path/to/my-class";

  myFunc();

  const inst = new MyClass();

  // Використовуйте іменований експорт, якщо необхідно експортувати декілька сутностей, а експорт за замовчуванням - для експорту однієї сутності. Хоча і можливо використовувати експорт за замовчуванням та іменований експорт в одному файлі, хорошою практикою буде вибрати тільки один стиль для кожного модуля.

  //!Знайомство з Webpack

  // Webpack - це збирач JS-модулів, менеджер модульних залежностей, який аналізує дерево залежностей і створює один або декілька результуючих файлів, що містять всю кодову базу проекту. Вибудовує порядок підключення модулів, збирає, мініфікує, запаковує та багато іншого.

  // Webpack став одним із найважливіших інструментів веб-розробника. В першу чергу - це менеджер модульних залежностей застосунку і збирач JS-файлів, але він може трансформувати усі ресурси (HTML і CSS, SASS тощо), оптимізувати зображення, компілювати шаблони, запускати локальний веб-сервер для розробки і багато іншого.

 //! Принцип роботи

// Припустимо, у нас є застосунок, який може виконувати дві прості математичні задачі: підсумовувати і множити. Ми вирішили розділити ці функції на окремі файли (модулі) для спрощення підтримки кодової бази. Таким чином, в index.html скрипти будуть підключені у такій послідовності.


// index.html
{/* <script src="sum.js"></script> */}
{/* <script src="multiply.js"></script> */}
{/* <script src="index.js"></script> */}

// Припустимо код з sum.js використовується в multiply.js та index.js, а код з multiply.js використовується тільки в index.js. Покажемо ієрархію залежностей на простій діаграмі.

// Якщо помилитися в послідовності підключення скриптів в index.html, тобто якщо index.js підключений перед будь-якою з інших залежностей або якщо sum.js доданий після multiply.js - виникнуть помилки. Тепер уявімо, що ми масштабуємо це до реального, повністю робочого застосунку - можуть бути сотні залежностей. Збереження порядку підключення буде жахом.

// Webpack перетворює залежності в модулі і зшиє в один або декілька файлів. Кожен модуль буде мати закритий простір імен і підключатися у потрібний час і правильному порядку.

// Gulp все ще займає гідне місце в інструментарії розробника і для деяких проектів функціонал Webpack не потрібен, хоча він може бездоганно працювати разом із ним. Попри те, що крива навчання може бути вищою у разі складніших налаштувань, Webpack - незамінний, якщо ви використовуєте сучасні бібліотеки і фреймворки для розробки, такі як React, Vue, Angular тощо.

//! Налаштування

// За посиланнями нижче ви знайдете вичерпні інструкції з покроковими поясненнями налаштування Webpack.

//! Формат JSON

// JSON (JavaScript Object Notation) - сучасний текстовий формат зберігання і передачі структурованих даних у текстовій формі. Звичний об'єктоподібний синтаксис JSON - дуже зручний. Саме у цьому форматі дані будуть приходити і відправлятися на сервер, зберігатися в локальному сховищі тощо.

// Але JSON - це не об'єкт, а його рядкове відображення. Нижче наведено приклад JSON файлу. Синтаксис схожий на об'єкт, за винятком того, що ключі - це завжди рядки у подвійних лапках. Рядкові значення також обов'язково повинні бути взяті у подвійні лапки. Значеннями властивостей можуть бути типи: string, number, object, array, boolean і null.

// user.json
{
  "name": "Josh",
  "weight": 175,
  "age": 30,
  "eyecolor": "brown",
  "isHappy": true,
  "cars": ["Chevy", "Honda"],
  "favoriteBook": {
    "title": "The Last Kingdom",
    "author": "Bernard Cornwell",
    "rating": 8.38
  }
}

// Javascript і JSON чудово працюють разом, завдяки методам вбудованого класу JSON, які перетворюють JavaScript об'єкт у JSON і навпаки. Незалежно від того, що у вас є, можна легко отримати зворотне.

//! Метод JSON.stringify()

// Приймає значення і перетворює його у JSON. Значенням може бути число, буль, null, масив або об'єкт. Рядки - це вже валідний JSON, тому в їх перетворенні немає сенсу.

const dog = {
  name: "Mango",
  age: 3,
  isHappy: true,
};

const dogJSON = JSON.stringify(dog);
console.log(dogJSON);// "{"name":"Mango","age":3,"isHappy":true}"

// Результат виклику JSON.stringify(dog) - це валідний JSON (рядок), який може бути збережений у файл або переданий мережею.

// Не будь-який JavaScript об'єкт може бути перетворений один до одного у JSON. Наприклад, якщо в об'єкта є методи, то при перетворенні вони будуть проігноровані.

const dog = {
  name: "Mango",
  age: 3,
  isHappy: true,
  bark() {
    console.log("Woof!");
  },
};

const dogJSON = JSON.stringify(dog);
console.log(dogJSON);// "{"name":"Mango","age":3,"isHappy":true}"

// Також, при спробі перетворити функцію в JSON, результатом буде undefined.

JSON.stringify(() => console.log("Well, this is awkward"));// undefined

//! Метод JSON.parse()

// Щоб отримати з JSON валідне JavaScript значення, його необхідно розпарсити (parse). Це операція зворотна перетворенню в рядок (stringify). Тепер, коли dog - це валідний об'єкт, з ним можна працювати звичайним чином.

const json = '{"name":"Mango","age":3,"isHappy":true}';

const dog = JSON.parse(json);
console.log(dog);// {name: "Mango", age: 3, isHappy: true}
console.log(dog.name);// "Mango"

//! Обробка помилок

// Якщо методам класу JSON передати невалідний JSON, то вони «викинуть» помилку і весь скрипт впаде. Для уникнення цього, використовується конструкція try...catch, яка дозволяє «ловити» і обробляти помилки виконання скрипта.

try {
  // Code that may throw a runtime error
  } catch (error) {
  // Error handling
  }


//  1 Спочатку виконується код всередині блоку try.
//  2 Якщо помилки відсутні, блок catch ігнорується і управління передається далі.
//  3 Якщо в блоці try сталася помилка, його виконання зупиняється та інтерпретатор переходить до блоку catch.

// Змінна error - це об'єкт помилки з інформацією про те, що сталося. У цього об'єкта є кілька корисних властивостей:

// name - тип помилки. Для помилки парса - це SyntaxError.
// message - повідомлення про деталі помилки.
// stack - стек викликів функцій на момент помилки. Використовується для налагодження.

// Наприклад, парс рядка призведе до такого сценарію, тому що рядок з символами - це невалідний JSON, оскільки не може бути перетворений у валідне JavaScript значення.

// Script will crash during parse
const data = JSON.parse("Well, this is awkward");
console.log("❌ You won't see this log");

// Використовуючи конструкцію try...catch, ми можемо обробити цей виняток таким чином, щоб скрипт продовжив працювати, навіть у разі помилки.

try {
  const data = JSON.parse("Well, this is awkward");
} catch (error) {
  console.log(error.name);// "SyntaxError"
  console.log(error.message);// Unexpected token W in JSON at position 0
}

console.log("✅ This is fine, we handled parse error in try...catch");

// Те саме буде при спробі парса невалідного JSON, який, наприклад, може прийти з бекенду або бути прочитаний з файлу. У прикладі у властивості username бракує подвійних лапок.

try {
  const data = JSON.parse('{username: "Mango"}');
} catch (error) {
  console.log(error.name);// "SyntaxError"
  console.log(error.message);// "Unexpected token u in JSON at position 1"
}

console.log("✅ This is fine, we handled parse error in try...catch");

//! Фази виконання коду

// В JavaScript код виконується не відразу, для початку рушію потрібно прочитати код і дізнатися, чи можливо його взагалі виконати.

// Фаза інтерпретації або оцінки (compile time, evaluation time) - підготовка перед виконанням коду, рушій знаходить синтаксичні помилки, помилки типізації тощо. Тобто код ще не виконується, тільки оцінюється. Якщо ця фаза пройшла успішно, це як мінімум означає, що в коді відсутні синтаксичні помилки і його можна запустити для виконання.

// Фаза виконання (runtime) - скрипт починає виконуватися, виконуються інструкції викликів функцій і оцінки виразів, відбувається пошук необхідних ідентифікаторів у відповідних областях видимості тощо.

// Якщо ця фаза завершилася успішно, отже скрипт написаний без явних помилок і завершив свою роботу. На цій фазі можуть бути помилки, пов'язані з відсутніми властивостями і змінними, перетворенням типів тощо, тобто щось, що відбувається тільки під час виконання коду.

// Спробуйте виконати наступний код. Оскільки ми зробили помилку і замість const намагаємося оголосити змінну value ключовим словом cos, на фазі компіляції буде виявлена синтаксична помилка і фаза виконання навіть не запуститься. В консолі ми відразу побачимо повідомлення про помилку.

console.log('This message will not appear in the console');

cos value = 5;

//! ЦІКАВО
// try...catch ловить тільки помилки, які виникли під час виконання коду (runtime errors). Це означає, що код повинен бути синтаксично правильним, інакше фаза виконання просто не запуститься. Помилки, які виникають під час фази оцінки, називаються помилками парсингу.

//! Веб-сховище

// Щоразу, коли ви змінюєте тему кольорів між світлою і темною, переглядаєте відео, додаєте товар у корзину, відкриваєте або закриваєте сайдбар, популярні веб-застосунки запам'ятовують стан інтерфейсу і у наступному відвідуванні відновлюють його.

// За замовчуванням стан інтерфейсу зберігається в пам'яті вкладки браузера і втрачається після закриття веб-застосунку. Щоб уникнути цього, необхідно десь зберегти дані про стан інтерфейсу між відвідуваннями сторінки. На допомогу приходить зберігання інформації про стан веб-застосунку на комп'ютері користувача.

//! Web Storage API

// Веб-сховище складається з локального сховища (localStorage) і сховища сеансів (sessionStorage). Забезпечує спосіб зберігання даних інтуїтивно зрозумілим чином у вигляді пар ключ:значення. Технічно у веб-сховище можна записати тільки рядки, але це не проблема, якщо використовувати методи класу JSON для перетворення складних типів. У веб-сховище не записують методи об'єктів або функції, тільки дані.

// Локальне сховище (localStorage) - унікальне для кожного веб-застосунку і буде однаковим на декількох вкладках, в яких він (веб-застосунок) запущений. Дані в локальному сховищі не видаляються, навіть після закриття браузера або вимкнення комп'ютера. Щоб їх видалити, необхідно використовувати JavaScript.

// Сховище сеансів (sessionStorage) схоже на локальне - воно також унікальне для кожного веб-застосунку, але час життя збережених даних обмежений сесією вкладки браузера. Щойно користувач закриває вкладку або браузер, дані очищаються. На практиці сховище сеансів використовується значно рідше.

//? ЦІКАВО
// У веб-сховищі не зберігають паролі, номери банківських карт і подібну конфіденційну інформацію. Якщо шкідливий скрипт отримає доступ до веб-сторінки, він без проблем прочитає ці дані.

//! Локальне сховище

// Дозволяє зберігати дані без закінчення терміну дії у форматі пар ключ:значення на комп'ютері користувача і читати їх при повторному відвідуванні сторінки. Локальне сховище і сховище сесії - це частина браузера, тому вони доступні як властивості об'єкта window, мають однаковий набір властивостей і методів, і відрізняються тільки поведінкою.

// setItem(key, value) - створює новий, або оновлює вже існуючий запис у сховищі.
// getItem(key) - повертає зі сховища значення з ключем key.
// removeItem(key) - видаляє зі сховища запис з ключем key.
// clear() - повністю очищає всі записи сховища.
// length - кількість записів у сховищі.

//! Збереження

// Використовуючи метод setItem(key, value), можна додати новий запис у вигляді пари ключ:значення.

localStorage.setItem("ui-theme", "light");
localStorage.setItem("sidebar", "expanded");
localStorage.setItem("notification-level", "mute");

// Якщо необхідно зберегти щось, крім рядка, наприклад, масив або об'єкт, необхідно перетворити їх у рядок методом JSON.stringify().

const settings = {
  theme: "dark",
  isAuthenticated: true,
  options: [1, 2, 3],
};

localStorage.setItem("settings", JSON.stringify(settings));

//! Читання

// Метод getItem(key) дозволяє прочитати зі сховища запис з ключем key. Якщо у сховищі відсутній запис з таким ключем, метод повертає null. Якщо значення - це звичайний рядок, немає потреби його парсити.

localStorage.setItem("ui-theme", "dark");

const theme = localStorage.getItem("ui-theme");
console.log(theme);// "dark"

// В іншому випадку, необхідно розпарсити значення методом JSON.parse(), щоб отримати валідні дані.

const settings = {
  theme: "dark",
  isAuthenticated: true,
  options: [1, 2, 3],
};

localStorage.setItem("settings", JSON.stringify(settings));

const savedSettings = localStorage.getItem("settings");
const parsedSettings = JSON.parse(savedSettings);
console.log(parsedSettings);// settings object

//? ЦІКАВО
// Не забувайте використовувати конструкцію try...catch з методом JSON.parse(), щоб уникнути «падіння» скрипту, якщо раптом прочитали невалідний JSON.

//! Видалення

// Метод removeItem(key) видаляє зі сховища вже існуючий запис з ключем key.

localStorage.setItem("ui-theme", "dark");
console.log(localStorage.getItem("ui-theme"));// "dark"

localStorage.removeItem("ui-theme");
console.log(localStorage.getItem("ui-theme"));// null

//! Очищення сховища

// Операція повного очищення сховища - небезпечна, оскільки може порушити записи, зроблені іншими розробниками проекту. Проте, якщо ви хочете повністю очистити сховище, потрібно викликати метод clear().

localStorage.setItem("ui-theme", "light");
localStorage.setItem("sidebar", "expanded");
localStorage.setItem("notification-level", "mute");
console.log(localStorage.getItem("ui-theme"));// "light"
console.log(localStorage.getItem("sidebar"));// "expanded"
console.log(localStorage.getItem("notification-level"));// "mute"

localStorage.clear();
console.log(localStorage.getItem("ui-theme"));// null
console.log(localStorage.getItem("sidebar"));// null
console.log(localStorage.getItem("notification-level"));// null

//! Зберігаємо повідомлення

// Створимо форму для введення повідомлення і будемо зберігати його в localStorage по сабміту. Змінюйте значення текстового поля і натискайте кнопку «Save». Текст в полі виведення зміниться на введений. Перезавантажте сторінку, і ви побачите той самий текст, хоча нічого ще не вводили. При завантаженні сторінки ми беремо з localStorage останнє збережене значення. Спочатку такий запис у сховищі відсутній, тому буде виведений порожній рядок.

// https://codepen.io/goit-academy/pen/XWMozzv

// Подивитися вміст веб-сховища можна в інструментах розробника на вкладці Application. Там само ви можете вручну видаляти і додавати записи. На практиці це використовується під час розробки та налагодження роботи застосунку.


//! Сервіс для localStorage

// Для того, щоб скоротити кількість повторюваного коду при роботі з веб-сховищем, можна написати сервіс зі стандартними методами, наприклад, save і load. Вони будуть абстрагувати повторюваний код перевірки помилок парса і подібну рутину.

// storage.js

const save = (key, value) => {
  try {
    const serializedState = JSON.stringify(value);
    localStorage.setItem(key, serializedState);
  } catch (error) {
    console.error("Set state error: ", error.message);
  }
};

const load = key => {
  try {
    const serializedState = localStorage.getItem(key);
    return serializedState === null ? undefined : JSON.parse(serializedState);
  } catch (error) {
    console.error("Get state error: ", error.message);
  }
};

export default {
  save,
  load,
};

// Тепер ми можемо безпечно додавати і читати записи з локального сховища. Спробуйте самостійно дописати метод remove(key) для видалення запису, аналогічно load(key) і save(key, value).
